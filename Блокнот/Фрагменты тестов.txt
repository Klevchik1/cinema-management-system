def test_fpos_01_registration_success(self):
    """FPOS-01: Успешная регистрация с верификацией email"""
    # Отправка формы регистрации
    response = self.client.post(reverse('register'), self.test_data)
    
    # Проверка редиректа на верификацию
    self.assertEqual(response.status_code, 302)
    self.assertRedirects(response, reverse('verify_email'))
    
    # Проверка создания временной записи
    pending_reg = PendingRegistration.objects.filter(
        email=self.test_email).first()
    self.assertIsNotNone(pending_reg)
    
    # Верификация email
    verification_data = {
        'verification_code': pending_reg.verification_code
    }
    response = self.client.post(reverse('verify_email'), verification_data)
    
    # Проверка создания пользователя
    user = User.objects.filter(email=self.test_email).first()
    self.assertIsNotNone(user)
    self.assertTrue(user.is_email_verified)

def test_fpos_02_pdf_report_generation(self):
    """FPOS-02: Успешная генерация PDF отчетов"""
    # Генерация финансового отчета
    pdf_buffer = generate_pdf_report(
        data=self.test_data,
        report_type='revenue',
        title='Тестовый финансовый отчет',
        filters={'period': 'daily'}
    )
    
    # Проверка корректности PDF
    pdf_content = pdf_buffer.getvalue()
    self.assertGreater(len(pdf_content), 0)
    self.assertIn(b'%PDF', pdf_content[:100])  # Сигнатура PDF
    
    # Сохранение для проверки
    with tempfile.NamedTemporaryFile(suffix='.pdf') as temp_file:
        temp_file.write(pdf_content)
        self.assertTrue(os.path.exists(temp_file.name))

def test_fpos_03_report_generation_success(self):
    """FPOS-03: Генерация аналитических отчетов"""
    # Отчет по популярным фильмам
    movies_report = ReportGenerator.get_popular_movies(limit=10)
    self.assertIsInstance(movies_report, list)
    
    # Отчет по загруженности залов
    halls_report = ReportGenerator.get_hall_occupancy()
    self.assertIsInstance(halls_report, list)
    
    # Статистика продаж
    sales_stats = ReportGenerator.get_sales_statistics()
    expected_keys = ['total_tickets', 'total_revenue', 'avg_ticket_price']
    for key in expected_keys:
        self.assertIn(key, sales_stats)

def test_func_neg_1_ticket_booking_negative_scenarios(self):
    """FUNC-NEG-1: Тест негативных сценариев бронирования"""
    # Попытка бронирования без выбора мест
    response = self.client.post(reverse('book_tickets'), {
        'screening_id': self.screening.id,
        'selected_seats': ''  # Пустой список
    })
    self.assertEqual(response.status_code, 302)
    
    # Попытка бронирования занятого места
    booked_seat_id = self.booked_seats[0].id
    response = self.client.post(reverse('book_tickets'), {
        'screening_id': self.screening.id,
        'selected_seats': json.dumps([booked_seat_id])
    }, follow=True)
    
    # Проверка сообщения об ошибке
    messages = list(response.context['messages'])
    error_found = any('уже занято' in str(message) for message in messages)
    self.assertTrue(error_found)

def test_func_neg_2_ticket_refund_negative_scenarios(self):
    """FUNC-NEG-2: Негативные сценарии возврата билетов"""
    # Попытка возврата билета на прошедший сеанс
    response = self.client.post(
        reverse('request_ticket_refund', args=[self.past_ticket.id]),
        follow=True
    )
    self.past_ticket.refresh_from_db()
    self.assertEqual(self.past_ticket.status.code, 'active')
    
    # Попытка возврата за 15 минут до начала
    can_refund, message = self.soon_ticket.can_be_refunded()
    self.assertFalse(can_refund)
    self.assertIn('30 минут', message)

def test_func_neg_3_intentional_validation_failures(self):
    """FUNC-NEG-3: Тест с намеренными ошибками валидации"""
    # Попытка создания пользователя с некорректным email
    with self.assertRaises(ValidationError):
        user = User(email='некорректный-email')
        user.full_clean()
    
    # Попытка создания дублирующего email
    User.objects.create_user(email='duplicate@example.com')
    with self.assertRaises(Exception) as context:
        user2 = User(email='duplicate@example.com')
        user2.save()
    self.assertIn('уже существует', str(context.exception))
    
    # Попытка создания пересекающихся сеансов
    with self.assertRaises(ValidationError) as context:
        screening2 = Screening(
            hall=self.hall,
            start_time=self.screening1.start_time + timedelta(minutes=30)
        )
        screening2.clean()
    self.assertIn('пересекается', str(context.exception).lower())